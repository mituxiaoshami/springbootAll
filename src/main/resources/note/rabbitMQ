消息队列:

主要是用来实现应用程序的异步和解耦，同时也能起到消息缓冲，消息分发的作用。

消息中间件最主要的目的:解耦

消息中间件的标准:生产者生产消息----传送----->消息队列   消费者----拿取------>消息队列

生产者不用关心是谁来消费   消费者不用关心是谁来生产消息  从而达到解耦的目的。

在分布式系统中   消息队列

RabbitMQ介绍：
RabbitMQ是实现AMQP（高级消息队列协议）的消息中间件的一种。
RabbitMQ主要是为了实现系统之间的双向解耦而实现的。当生产者大量产生数据时，消费者无法快速消费，那么需要一个中间层。保存这个数据。

AMQP(高级消息队列协议)
AMQP，即Advanced Message Queuing Protocol，高级消息队列协议，是应用层协议的一个开放标准，为面向消息的中间件设计。
消息中间件主要用于组件之间的解耦，消息的发送者无需知道消息使用者的存在，反之亦然。
AMQP的主要特征是面向消息、队列、路由（包括点对点和发布/订阅）、可靠性、安全。

相关概念:
通常我们谈到队列服务, 会有三个概念： 发消息者(生产者)、队列(消息队列)、收消息者(消费者)
RabbitMQ 在这个基本概念之上, 多做了一层抽象, 在生产者和队列之间，加入了交换器。
这样生产者和队列之间没有直接联系----转变成生产者把消息给交换器，交换器根据调度策略再把消息给消息队列


其中比较重要的概念有4个，分别为:虚拟主机，交换机，队列和绑定。

虚拟主机:一个虚拟主机持有一组交换机、队列和绑定。
为什么需要多个虚拟主机？
RabbitMQ当中，用户只能在虚拟主机的粒度进行权限控制。 如果需要禁止A组访问B组的交换机/队列/绑定，必须为A和B分别创建一个虚拟主机。每一个RabbitMQ服务器都有一个默认的虚拟主机“/”。

交换机:Exchange 用于转发消息，但是它不会做存储 ，如果没有 Queue bind 到 Exchange 的话，它会直接丢弃掉 Producer 发送过来的消息。
这里有一个比较重要的概念：路由键。
消息到交换机的时候，交换机会转发到队列中，那么究竟转发到哪个队列，就要根据该路由键。

绑定：交换机需要和队列相绑定。


交换机(Exchange)
交换机的功能主要是接收消息并且转发到绑定的队列，交换机不存储消息，在启用ack模式后，交换机找不到队列会返回错误。
交换机有四种类型：Direct, topic, Headers and Fanout

Direct：
Direct Exchange是RabbitMQ默认的交换机模式，也是最简单的模式，根据key全文匹配去寻找队列。

Topic:
Topic Exchange 转发消息主要是根据通配符。
在这种交换机下，队列和交换机的绑定会定义一种路由模式，那么，通配符就要在这种路由模式和路由键之间匹配后交换机才能转发消息。

在这种交换机模式下：
1、路由键必须是一串字符，用句号（.） 隔开，比如说 agreements.us，或者 agreements.eu.stockholm 等。
2、路由模式必须包含一个 星号（*），主要用于匹配路由键指定位置的一个单词，
比如说，一个路由模式是这样子：agreements..b.*，那么就只能匹配路由键是这样子的：
第一个单词是 agreements，第四个单词是 b。
井号（#）就表示相当于一个或者多个单词，
例如一个匹配模式是agreements.eu.berlin.#，那么，以agreements.eu.berlin开头的路由键都是可以的。

具体代码发送的时候还是一样，第一个参数表示交换机，第二个参数表示routing key，第三个参数即消息。如下：
rabbitTemplate.convertAndSend("testTopicExchange","key1.a.c.key2", " this is RabbitMQ!");

topic 和 direct 类似, 只是匹配上支持了”模式”, 在”点分”的 routing_key 形式中, 可以使用两个通配符:

*表示一个词.
#表示零个或多个词.

Headers:
headers 也是根据规则匹配, 相较于 direct 和 topic 固定地使用 routing_key , headers 则是一个自定义匹配规则的类型.
在队列与交换器绑定时, 会设定一组键值对规则, 消息中也包括一组键值对( headers 属性), 当这些键值对有一对, 或全部匹配时, 消息被投送到对应队列。


Fanout:
Fanout Exchange 消息广播的模式，不管路由键或者是路由模式，会把消息发给绑定给它的全部队列，如果配置了routing_key会被忽略。